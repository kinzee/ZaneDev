---
title: "弹珠技术总结(二)：技能系统"
date: 2026-01-26T15:36:40+08:00
lastmod: 2026-01-26T15:36:40+08:00
draft: false
tags: [Unity, GameDev]
categories: [GameDev,弹珠技术总结]
summary: "弹珠游戏中的技能实现"

# PaperMod主题配置
showToc: true
tocOpen: false
ShowReadingTime: true
ShowBreadCrumbs: true
ShowPostNavLinks: true
ShowWordCount: true
ShowRssButtonInSectionTermList: true
UseHugoToc: true

# 封面图片（可选）
cover:
    image: "" # 图片路径/URL
    alt: "" # 替代文本
    caption: "" # 封面下的文字说明
    relative: false # 使用页面捆绑包时设为true
    hidden: true # 仅在当前单页隐藏
---

整个项目的开发周期差不多1年，但是有技术价值，值得说说的并不多。
时间都去哪儿了？改需求，更新UI，系统玩法开发。

## 游戏中的技能

- 弹珠的专属技能。弹珠在发射，碰撞，攻击敌方单位后会产生特殊效果。比如某颗弹珠每命中5颗钉子，获得10层“闪避”。
- 遗物（早期版本）。玩家携带的特殊道具，使用场景更加广泛，也不局限于某颗弹珠上。
- 玩家装备，天赋，武器。这些都是局外养成的内容。

**需要解决的问题：**

1. 时间紧，技能多
2. 容易配置与维护
3. 技能之间的相互影响

## 框架设计

在分析大部分技能之后，我将技能的一次完整执行设计成一个通用管线。管线拆分成4个核心组件：

- 触发方式
- 触发条件
- 触发目标
- 触发效果

以上面某个弹珠技能为例，命中钉子（触发方式）-> 每5颗（触发条件）-> 主角（目标）-> 获得10层闪避（效果）。
这4个组件既是Excel表中的可配置项，也是程序需要针对性实现的原子逻辑。
这些原子逻辑就像管道，漏斗，控制数据流入流出，执行具体的行为。我们可以清晰地定位到技能可能发生错误的环节。也可以很方便地拓展节点，比如在触发目标和触发效果之间新增筛选目标的流程，满足类似于（生命值大于50%的敌方单位）特殊目标需求。

策划通过搭积木的方式自由组合效果，可以快速扩充技能库。

这里还有个问题需要解决。治疗，造成伤害这种类型的`Action`都能快速实现。但是我们怎么去实现**获得闪避效果**呢。貌似前面抽象得如何简洁，技能逻辑足够清晰，但是复杂逻辑全集中在了**闪避**的实现上。我们无法在上面的技能系统中维护这个持续性的状态。到这一步，稍微有点战斗开发经验的人员就可以意识到，我们可以用`Buff`。是的，策划只要在效果中配置`（AddBuff, 闪避BuffId）`就实现了获得闪避效果。

Buff系统除了常规的设计外还沿用了技能的核心组件。比如闪避效果具体的配置就会变成受到到攻击阶段 -> 判断是否触发 -> 本次攻击是否命中。策划可以复用技能中的一些配置项，程序也不需要实现额外的逻辑。

基于这套框架，开发差不多在2个周左右的时间完成了几百个技能。当前的技能差不多有700多个（当然有些技能只是简单的数值升级）。

最近看到一篇文章中提到了**TCA战斗系统框架**，核心思想是将所有战斗交互抽象为**触发器（Trigger）**-> **条件（Condition）**-> **动作（Action）**三个核心组件的链式执行流程。简直不谋而合！好用的设计总是心有灵犀的。

## 具体实现

配置表

![excel](/img/Snipaste_2026-01-27_10-29-33.png)

### SkillEvent

技能事件，内部定义的ID映射技能的触发方式。

### SkillComponent

技能核心组件，负责技能的添加和移除。

通过消息订阅触发技能。

完整的技能执行流程。

### SkillCondition

``` c#
// 是否满足整除
[SkillCondition(6)]
public class IsDBIntCondition : SkillConditionFunc<string, int>
{
    public override bool Evaluate(TriggerContext context)
    {
        var blackBoard = context.owner.GetOrAddComponent<Blackboard>();
        if (blackBoard.GetInt(value1) == 0)
        {
            return false;
        }
        return blackBoard.GetInt(value1) % value2 == 0;
    }
}
```

### TargetFilter

``` c#
// 获取玩家
[TargetSelector(3)]
public class PlayerSelector : ITargetSelector
{
    public IEnumerable<T> SelectTargets<T>(TriggerContext context) where T : class
    {
        var player = GameManager.Instance.GetRoundPlayer();
        if (player is T target)
        {
            yield return target;
        }
    }
}
```

### TargetSelector

``` c#
// 筛选拥有指定Buff的目标
[TargetFilter(3)]
public class HasBuff : ITargetFilter
{
    [ExcelParameter(1)] public int buffTag;

    public IEnumerable<T> Filter<T>(IEnumerable<T> inputTargets, TriggerContext context) where T : class
    {
        return inputTargets.Where(x => x is ICanAddBuff owner && owner.BuffComponent.HasBuffByTag(buffTag));
    }
}
```

### Effect

``` c#
/// <summary>
/// 添加buff
/// </summary>
[Effect(8)]
[Preserve]
public class AddBuff : SkillEffect<ICanAddBuff>
{
    [EffectParameter(1)] public int buffId;
    [EffectParameter(2)] public int layer;
    
    private TriggerContext _context;

    public override void Execute(TriggerContext context, ITargetSelector selector)
    {
        _context = context;
        base.Execute(context, selector);
    }

    public override void Apply(ICanAddBuff target)
    {
        if (target == null) return;
        BuffUtils.AddBuff(target.BuffComponent, buffId, layer, _context.owner);
    }

    public override void Clear()
    {
    }
}
```

### 其他问题

#### 技能音效与动效

在程序看来，播放技能音效与动效本身也是`Action`。技能效果支持顺序执行多个配置的`Action`。程序只要实现`PlayEffect(params)`即可，并且搭配`Delay`之类的`Action`还能控制播放时机。但是策划接受不了这种方式，最后在技能表新增一项用来配置动效播放方式和动效。

#### Buff的定义

我希望一切状态即buff，闪避=buff。但在策划看来，闪避buff = 维护闪避效果（添加或移除绑定的闪避组件）。这样闪避最终的逻辑完全由程序去维护，也无法配置相关的动效音效。当然也有优点，开发对应组件比拆分原子逻辑更加直接和简单。
